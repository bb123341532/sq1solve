# Square-1 megoldó program
![Egy kép a Square-1 puzzle 3 különböző összekeveréséről](https://github.com/bb123341532/sq1solve/blob/main/sqone.jpg)
## A program használata
A program futás folyamán bekéri a puzzle aktuális helyzetét különféle módokon, hibás beolvasások elkerülése érdekében tanácsolt a puzzle-t a lehető legkockaalakúbb formában tartani, a program bemenetet szóközökkel elválasztva tudja feldolgozni, valamint minden bemenetet úgy kell megadni, hogy puzzle-t félbevágó síkhoz illeszted az egyik elemet mindkét rétegben, majd ha a bemenet igényel sarok elemet, akkor a félbevágó síktól óramutató járásával megegyező irányban az első elemmel kell kezdeni, ha viszont nem, akkor a másik irányba az első él elemmel, ezután az óramutató járásával ellenkező irányban a következő igényelt elemmel kell folytatni. Az első bemenet mindig a felső réteg, a második az alsó réteg, ahhoz, hogy a puzzle helyes pozícióba kerüljön az alsó réteg beolvasásához, a szemben lévő(narancssárga) oldalt elől tartva az egész puzzle-t 180°-kal kell elforgatni, majd a felső rétegre igaz beolvasási szabály szerint megadni az alsó réteg elemeit is(beolvasás után vissza kell forgatni a puzzle-t, hogy újra a "felső" réteg legyen felül).  A továbbiakban minden lépéshez a bekért bemenet felépítését magyarázom.  
- Az első lépésnél(a később elmagyarázott) kirakási metódus milyensége miatt a program csak a felső réteg elemeire koncentrál. A bemenetnek itt 10 betűből(és az őket elválasztó 9 szóközből) kell állnia, ezek a betűk lehetnek "e"(edge - él-elem) vagy "c"(corner - sarok-elem) betűk, attól függően, hogy milyen elem van a beolvasási sorrend első helyén, illetve mi következik utána. Egy példa erre a bemenetre: "c e e e c e e e e e".
- A második lépésnél a program már igényli mindkét réteget, valamint most már a hátralévő lépések is mind fogják. A rétegekben elhelyezkedő sarok-elemek "domináns"(citromsárga vagy fehér színnel rendelkezik) színére van szüksége. Itt 4 betűt kell megadni mindkét réteghez, ezek a betűk lehetnek "y"(yellow - citromsárga) vagy "w"(white - fehér) betűk, attól függően, hogy a soron következő elemnek citromsárga vagy fehér a domináns színe. Egy példa ezekre a bemenetekre: "y w w y".
- A harmadik lépés nagyon hasonló a másodikhoz, viszont itt a program a sarok-elemek helyett, az adott rétegekben szereplő él-elemek domináns színére kíváncsi. Egy példa ezekre a bemenetekre: "w w y w".
- A negyedik(és ötödik) lépés komplikáltabb az eddigieknél. A negyedik lépésben csak a sarkokat kell megadni, viszont itt már egy sarok-elemet nem csak 1 karakter jelöl, hanem 3. Amikor beolvasunk egy sarok-elemet, akkor az első betű a domináns színe("y"/"w"), ezután az óramutató járásával megegyező irányban kell beolvasni a maradék 2 színt az adott elemen, ezek a színek az angol nyelvbéli megfelelőjük első betűje, tehát "b" = kék, "o" = narancssárga, "g" = zöld, "r" = piros. A szokásos beolvasási sorrend szerint, kell beolvasni az elemeket, elemek között szóközzel elválasztva. Egy példa ezekre a bemenetekre: "ybo yrb ygr yog".
- Az ötödik lépésben már az egyes rétegek összes elemére szüksége van a programnak, a sarok-elemeket a negyedik lépés szerint kell beolvasni, viszont ebben a lépésben már felváltva vannak beolvasva a sarok és él-elemek. Az él elemeket ugyan csak a domináns színével kezdjük("y"/"w") és ezután befejezzük a másodlagos színével(a negyedik lépésben leírt színkódolás szerint). Ez a lépés is követi a szokásos beolvasási sorrendet. Egy példa erre a bemenetre: "ygr yg yog yo ybo yb yrb yr".
- A hatodik lépésben az egyetlen bekért bement csak egy válasz arra a kérdésre, hogy a középső réteg kirakott állásban van-e. Erre a válasz lehet "y"(yes - igen) vagy "n"(no - nem), és ennek függvényében ad vissza a program egy algoritmust, illetve ha a válasz "y"("igen", akkor nem ad vissza semmit).

A bemenetek megadását követően a program 2 dolgot csinál kimenet szempontjából. Egyrészt kiírja a végrehajtandó algoritmust a következő formában: "(t/b)    {algoritmus}". Az első kifejezés végrehajtása után kerül a puzzle olyan elforgatásba, hogy az algoritmus elvégzése a keresett eredménnyel járjon. A kimenetként visszaadott kifejezés és algoritmus magyarázata "A puzzle alapjai" alcím 3. paragrafusában található.  
Az algoritmuson kívül még egy illusztrációt is visszaad a program a puzzle aktuális helyzetéről, ez egy felső és egy alsó nézet, értelemszerűen a visszaadott képen, a felső ábra a felső nézet, az alsó ábra az alsó nézet. Ha a "felső réteg" van felül, és a narancssárga oldal néz előre, akkor a puzzle felénk, vagy a másik irányba való döntésével tudjuk elérni azt a nézetet, amit a visszaadott kép ábrázol. Az ábrákban a középső négyzet mindig fekete színű lesz, miután a tényleges puzzle-ön az az elem "nem létezik". Az ábrákban lehetséges, hogy az elemek egy sötét szürke színnel vannak kitöltve, ez azt jelenti, hogy a kirakás aktuális fázisában ezek az elemek nem relevánsak.  
![Egy példa a nem releváns elemek szürke színére](https://github.com/bb123341532/sq1solve/blob/main/abra.png)      ![A teljesen kirakott állapotban lévő puzzle ábrája](https://github.com/bb123341532/sq1solve/blob/main/download.png)  
Amennyiben a program kimenete "lmao" hibakód(Layer Misaligned,Algorithm Off), ez azt jelenti, hogy a bemenet hibásan lett megadva. Lehetséges hibák amikre érdemes figyelni: szóközök kihagyása, sarok-elemek színeinek rossz sorrendben való beolvasása, sarok és él-elemek nem váltakozva beolvasása(ahol mindkettőre szükség van).
## A program működése
A program minden bemenetet ugyan úgy kezel, miután minden bemenet hasonlóan néz ki, mégpedig 1,2 vagy 3 karakter hosszú láncok szóközökkel elválasztva. Beolvasás után a szóközök mentén feldarabolja a bementek stringjét és eltárolja őket. A program előre megírt esetekre vizsgálja a bemenet tömbjét. Az előre megírt esetek lépésenként 3(első lépésnél csak 2) listában vannak eltárolva, ezekben a listákban szerepelnek a felső és alsó rétegek lehetséges állásai, valamint az ezekhez tartozó algoritmusok, triviális, hogy a felső réteg listájának az i-edik rekeszében lévő álláshoz tartozik az alsó réteg listájának az i-edik rekeszében lévő állás, valamint az algoritmusok listájának az i-edik rekeszében lévő algoritmus.  
Az első három lépésben elég végig menni a megadott állások listáin, valamint azok elforgatásain. Erre vannak implementálva segéd-függvények, ezek bemenete az éppen tesztelendő állás, kimenete pedig a tesztelendő állás összes lehetséges elforgatásáról egy újabb lista. Tehát ha például a második lépésnél tartunk, akkor egy tesztelendő lehetséges állás nézhet ki úgy string formában, hogy "y y w y"(ez ügye azt jelenti, hogy az adott rétegben 3 citromsárga és 1 fehér sarok-elem van), miután ezt átfuttatjuk az elforgató segédfüggvényen, a kimenete egy olyan lista lenne, aminek az elemei az alábbi stringekből képezhetők: "y y w y";"y y y w";"w y y y ";"y w y y". Miután létre lettek hozva ezek a segéd listák, a program nem csak arra használja őket, hogy segítsenek beazonosítani a helyes állást, hanem az algoritmus végrehajtása előtti javító kifejezés meghatározását is lehetővé teszik. Az alapján, hogy a segéd listában hányadik rekeszben van a ténylegesen megfelelő állapot, a program kiszámolja a súlyozás segítségével, hogy mi a kellő javító kifejezés, hogy az algoritmus elvégzéséhez előkészítse a puzzle-t.
A negyedik és ötödik lépés ennél komplikáltabb. Miután itt már nem csak az elemek típusa és domináns színe számít, hanem az elemek összes színe, ezért sokkal több, pontosan 4-szer annyi, lehetőség van. Ezért ebben a két lépésben az elforgatások segéd listáinak létrehozásán(itt is segít kiszámolni a javító kifejezés értékeit) kívül van egy másik segéd függvény is. Ez a segéd függvény hozza létre az aktuálisan tesztelt állás összes lehetséges elforgatására, az összes lehetséges szín kombinációt. Miután a színek egymáshoz képesti relatív helyzete állandó, ezért elég a bemeneteken elvégezni többször egy matematikai permutációt, ami a felhasznált színkódolással úgy nézne ki, hogy (obrg), vagyis narancssárga->kék->piros->zöld(->narancssárga). Ez a permutáció egy konkrét elemen végrehajtva így nézne ki: ybo(citromsárga-kék-narancssárga sarok)->yrb(citromsárga-piros-kék sarok), ez a példa konkrétan egy sarok-elemet mutat be, a negyedik lépés csak sarok-elemekkel foglalkozik. Az ötödik lépésben is hasonlóan működik, csak ott a sarok-elemeken túl, az él-elemeken is végre van hajtva, például: wr(fehér-piros él)->wg(fehér-zöld él).  
A képek generálására is a színkódolás van felhasználva. Egy képen összesen 42 darab kiszínezendő tartomány van(ebből 2 mindig fekete), egyik fele a felső réteghez, másik fele az alsó réteghez. A program a bemenet megadása után minden tartomány színét tartalmazó változót a korábban említett szürke színre állít, majd a 2 korábban említett tartományt feketére. Ezután a bemeneti stringeket újra feldarabolja a szóközök mentén, majd a kapott tömb egy specifikus rekeszéből, egy specifikus karaktert eltárol a megfelelő tartomány színét meghatározó változóba. Miután minden kellő tartománynak megadta a színét, a változókban szereplő színek alapján elkészíti a képeket. A program írása közben minimális probléma volt, hogy a Python MatPlotLib nevű programcsomagja a narancssárga színt "orange"-ként ismeri fel, viszont a bemenetünkben a narancssárga színt szimpla "o" betűvel jelöltük, ezért az ábrák színeit tartalmazó változókat tartalmazó tömbön egy újabb segéd függvény végigmegy, és amelyik rekeszben annyi van eltárolva, hogy "o", azt megváltoztatja arra, hogy "orange".
## A puzzle alapjai
A [Square-1](https://en.wikipedia.org/wiki/Square-1_(puzzle)) egy normális Rubik-kocka működésétől eltér, a megszokott lehetséges lépések többnyire nem relevánsak ehhez a puzzle-höz, valamint a "kockát" egész egyszerűen át lehet alakítani nem kocka alakúra. Az egyik legszembetűnőbb változás a "középső" rétegen látszik, itt összesen 2 elemből áll, felső nézetből ez a réteg fel tud venni négyzet alakot és egy úgynevezett "papírsárkány" alakot, ez az a réteg, aminek a segítségével tudjuk a puzzle elemeit orientálni és permutálni. Az "alsó" és "felső" réteg sem szokványos, a szokásos 9 négyzet helyett csak 8 elemből áll egy réteg, ez 4 él-elem(háromszög alakú) és 4 sarok-elem(deltoid alakú). Felső nézetből a (szokványos kockán) középső elem helyett egy üreg van, ahol alapvetően a puzzle-t egybetartó csavarok vannak, de ami számít, hogy ez a 2 csavar körül forog az adott réteg, ha körként tekintünk rá, akkor az él-elemek 30°, míg a sarok-elemek 60°-ot foglalnak el(4×30°+4×60°=360°). A puzzle kialakításából is adódik, hogy a "kocka" nem is feltétlenül kocka, például az is lehetséges, hogy a felső rétegben 2 él-elem és 5 sarok-elem helyezkedik el. Az elemek orientálása is eltér a megszokottól, szokványos kockán az él elemek 2, a sarok elemek 3 különböző módon lehetnek orientálva, itt minden (permutálható) elem csak 2 féle módon lehet orientálva, ami ekvivalens azzal, hogy melyik rétegben van, például, ha egy elem "felfele" néz, akkor az garantálja, hogy a felső rétegben van, vagy ha egy másik az alsó rétegben van, akkor az garantálja, hogy "lefele" néz.  

A puzzle kirakása is eltér a szokványostól, a szimpla kockát bárhogy tarthatod a kezedben, ugyan azok az forgatások állnak rendelkezésedre, itt van egy specifikus módja a puzzle tartásának, ami az összes lehetséges forgatást elérhetővé teszi, ez pedig a következő: a középső réteg, a már korábban említett, 2 elemre van felbontva, mindkettő egy trapéz, amiket helyesen egymás mellé illesztve, egy négyzet alakul. Az egyik trapéz látszó oldalai narancssárga-zöld-piros színűek, ha ennek az elemnek a narancssárga oldalára illeszted a bal hüvelykujjad és a piros oldalára a bal középső  ujjad, akkor egyszerűen hozzáférsz minden lehetséges forgatáshoz(a program használatához kötelező ez a tartás).  

A puzzle lehetséges forgatásai a következők: felső réteg forgatása, alsó réteg forgatása és a "slice". A felső és alsó rétegek elforgatása azon múlik, hogy az adott algoritmus, adott lépésében milyen szám áll. Korábban már említve volt, hogy az élek 30°, a sarkok pedig 60°-ot foglalnak el, egy másik értelmezése ennek, hogy a különböző elemeknek, különböző "súlya" van, ami eddig 30°-ot foglalt el, annak a súlya 1, míg a 60°-os elemeknek 2. Az algoritmusokban a rétegek forgatásai (t,b)-vel vannak jelölve, ahol -6<t,b<=6 egész szám, a t azt jelöli, hogy hány "elemnyi súllyal" kell elforgatni a felső réteget, míg a b ugyan ez az alsó rétegre, ha felülről/alulról nézed a puzzle-t, akkor a pozitív számok óramutató járásával megegyező forgatást jelölnek, míg a negatívok ellenkező irányút, szokványos algoritmusokban nem szokott megjelenni a -6 szám, miután ugyan azt a forgatás éri el, mint a 6-os forgatás. Tehát a (-2,3) kifejezés azt jelenti, hogy a felső réteget 2 súllyal(60°-kal) az óramutató járásával ellentétes irányba kell forgatni, az alsó réteget pedig 3 súllyal(90°-kal) az óramutató járásával megegyező irányba kell forgatni. A "slice" az a forgatás, amikor a puzzle-t félbevágó sík mentén 180°-kal elforgatod, ilyenkor a forgatott fél által tartalmazott elemek réteget(és orientációt) cserélnek egymással, ez a forgatás az algoritmusokban "/"(forward slash) jellel van leírva. Tehát egy komplett algoritmus úgy néz ki, hogy (t<sub>1</sub>,b<sub>1</sub>)/(t<sub>2</sub>,b<sub>2</sub>)/.../(t<sub>n</sub>,b<sub>n</sub>). (Ez triviális, viszont mégis érdemes leírnom, a legtöbb algoritmust a puzzle egy bizonyos helyzetére kell elvégezni, ezért nem mindegy, hogy milyen az aktuális elforgatás, az kellő algoritmushoz képest. Ennek kiküszöbölése érdekében a program minden ilyen algoritmus előtt kiír egy "javító forgatást", ami annyit tesz, hogy az algoritmus elvégzéséhez helyes állapotba forgatja a puzzle rétegeit, ez a javító forgatás a tényleges algoritmustól 4 szóközzel van elválasztva.)  
![A forgatások ábrázolva](https://github.com/bb123341532/sq1solve/blob/main/noti.png)

Összekeverés után nagy valószínűséggel a puzzle nem kocka alakú, bár létezik konkrét algoritmus a puzzle minden elem-típusára nézett permutációjára, egyszerűen annyi különböző lehetőség van, hogy nem éri meg foglalkozni ezzel, a haladó kirakási metódusok is nagy részben intuíciót használnak, ezáltal a több mint 170 algoritmus helyett, elég csak 5-öt megtanulni. Az intuíciót alkalmazó része a következő: el kell érni, hogy az alsó rétegbe kerüljön 6 darab sarok-elem, vagyis az alsó rétegben csak sarkok lehetnek, a felső rétegben ezáltal 8 él és 2 sarok-elem van, ha ezután elvégzed az adott algoritmust akkor a puzzle (a középső réteg nem feltétlenül, de azt a kirakás végén lehet javítani) visszatér kocka alakúra, vagyis ekkor garantált, hogy a felső és alsó rétegekben 4 él és 4 sarok elem van, valamint hogy azok felváltva következnek egymás után, tehát az alsó és felső rétegek is visszatértek négyzet alapúra. A következő lépés az elemek orientálása, a szokványos kockához képest, itt az összes sarkot, majd az összes élet egy-egy algoritmussal helyes orientációba lehet hozni, sőt, ha helyes algoritmusokat hajtunk végre, akkor orientálás után nem is tudnak többet réteget cserélni a kirakás során. Ezután a sarkok és élek permutálása következik, ezeket ugyan csak meg lehet oldani egy-egy algoritmussal. A kirakás utolsó lépése a középső réteg javítása, amennyiben kocka alapú már a középső réteg, nem kell semmit sem csinálnunk, ha viszont nem az, akkor van egy egyszerű algoritmus, ami ezt megoldja.
