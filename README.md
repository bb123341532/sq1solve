# Square-1 megoldó program
## A program használata
A program futás folyamán bekéri a puzzle aktuális helyzetét különféle módokon, hibás beolvasások elkerülése érdekében tanácsolt a puzzle-t a lehető legkockaalakúbb formában tartani, a program bemenetet szóközökkel elválasztva tudja feldolgozni, valamint minden bemenetet úgy kell megadni, hogy puzzle-t félbevágó síkhoz illeszted az egyik elemet mindkét rétegben, majd ha a bemenet igényel sarok elemet, akkor a félbevágó síktól óramuató járásával megegyező irányban az első elemmel kell kezdeni, ha viszont nem, akkor a másik irányba az első él elemmel, ezután az óramutató járásával ellenkező irányban a következő igányelt elemmel kell folytatni. Az első bemenet mindig a felső réteg, a második az alsó réteg, ahhoz hogy a puzzle helyes pozícióba kerüljön az alsó réteg beolvasásához, a szemben lévő(narancssárga) oldalt elől tartva az egész puzzle-t 180°-kal kell elforgatni, majd a felső rétegre igaz beolvasási szabály szerint megadni az alsó réteg elemeit is(beolvasás után vissza kell forgatni a puzzle-t, hogy újra a "felső" réteg legyen felül).  A továbbiakban minden lépéshez a bekért bemenet felépítését magyarázom.  
- Az első lépésnél(a később elmagyarázott) kirakási metódus milyensége miatt a program csak a felső réteg elemeire koncentrál. A bemenetnek itt 10 betűből(és az őket elválasztó 9 szóközből) kell állnia, ezek a betűk lehetnek "e"(edge - él-elem) vagy "c"(corner - sarok-elem) betűk, attól függően, hogy milyen elem van a beolvasási sorrend első helyén, illetve mi következik utána. Egy példa erre a bemenetre: "c e e e c e e e e e".
- A második lépésnél a program már igényli mindkét réteget, valamint most már a hátralévő lépések is mind fogják. A rétegekben elhelyezkedő sarok-elemek "domináns"(citromsárga vagy fehér színnel rendelkezik) színére van szüksége. Itt 4 betűt kell megadni mindkét rétghez, ezek a betűk lehetnek "y"(yellow - citromsárga) vagy "w"(white - fehér) betűk, attól függően, hogy a soron következő elemnek citromsárga vagy fehér a domináns színe. Egy példa ezekre a bemenetekre: "y w w y".
- A harmadik lépés nagyon hasonló a másodikhoz, viszont itt a program a sarok-elemek helyett, az adott rétegekben szereplő él-elemek domináns színére kíváncsi. Egy példa ezekre a bemenetekre: "w w y w".
- A negyedik(és ötödik) lépés komplikáltabb az eddigieknél. A negyedik lépésben csak a sarkakat kell megadni, viszont itt már egy sarok-elemet nem csak 1 karakter jelöl, hanem 3. Amikor beolvasunk egy sarok-elemet, akkor az első betű a domináns színe("y"/"w"), ezután az óramutató járásával megegyező irányban kell beolvasni a maradék 2 színt az adott elemen, ezek a színek az angol nyelvbéli megfelelőjük első betűje, theát "b" = kék, "o" = narancssárga, "g" = zöld, "r" = piros. A szokásos beolvasási sorrend szerint, kell beolvasni az elemeket, elemek között szóközzel elválasztva. Egy példa ezekre a bemenetekre: "ybo yrb ygr yog".
- Az ötödik lépésben már az egyes rétegek összes elemére szüksége van a programnak, a sarok-elemeket a negyedik lépés szerint kell beolvasni, viszont ebben a lépésben már felváltva vannak beolvasva a sarok és él-elemek. Az él elemeket ugyan csak a domináns színével kezdjük("y"/"w") és ezután befejezzük a másodlagos színével(a negyedik lépésben leírt színkódolás szerint). Ez a lépés is követi a szokásos beolvasási sorrendet. Egy példa erre a bemenetre: "ygr yg yog yo ybo yb yrb yr".  

A bemenetek megadását követően a program 2 dolgot csinál kimenet szempontjából. Egyrészt kiírja a végrehajtandó algoritmust a következő formában: "(t/b)    {algoritmus}". Az első kifejezés végrehajtása után kerül a puzzle olyan elforgatásba, hogy az algoritmus elvégzése a keresett eredménynel járjon. A kimenetként visszaadott kifejezés és algoritmus magyarázata "A puzzle alapjai" alcím 3. paragrafusában található.  
Az algoritmuson kívül még egy illusztrációt is visszaad a puzzle aktuális helyzetéről
## A program működése

## A puzzle alapjai
A [Square-1](https://en.wikipedia.org/wiki/Square-1_(puzzle)) egy normális Rubik-kocka működésétől eltér, a megszokott lehetséges lépések többnyire nem relevánsak ehhez a puzzle-höz, valamint a "kockát" egész egyszerűen át lehet alakítani nem kocka alakúra. Az egyik legszembetűnőb változás a "középső" rétegen látszik, itt összesen 2 elemből áll, felső nézetből ez a réteg fel tud venni négyzet alakot és egy úgynevezett "papírsárkány" alakot, ez az a réteg aminek a segítségével tudjuk a puzzle elemeit orientálni és permutálni. Az "alsó" és "felső" réteg sem szokványos, a szokásos 9 négyzet helyett csak 8 elemből áll egy réteg, ez 4 él-elem(háromszög alakú) és 4 sarok-elem(deltoid alakú). Felső nézetből a (szokványos kockán) középső elem helyett egy üreg van ahol alapvetően a puzzle-t egybetartó csavarok vannak, de ami számít, hogy ez a 2 csavar körül forog az adott réteg, ha körként tekintünk rá, akkor az él-elemek 30°, míg a sarok-elemek 60°-ot foglalnak el(4×30°+4×60°=360°). A puzzle kialakításából is adódik, hogy a "kocka" nem is feltétlenül kocka, például az is lehetséges, hogy a felső rétegben 2 él-elem és 5 sarok-elem helyezkedik el. Az elemek orientálása is eltér a megszokottól, szokványos kockán az él elemek 2, a sarok elemek 3 különböző módon lehetnek orientálva, itt minden (permutálható) elem csak 2 féle módon lehet orientálva, ami ekvivalens azzal, hogy melyik rétegben van, például ha egy elem "felfele" néz, akkor az garantálja, hogy a felső rétegben van, vagy ha egy másik az alsó rétegben van, akkor az garantálja, hogy "lefele" néz.  

A puzzle kirakása is eltér a szokványostól, a szimpla kockát bárhogy tarthatod a kezedben, ugyan azok az forgatások állnak rendelkezésedre, itt van egy specifikus módja a puzzle tartásának, ami az összes lehetséges forgatást elérhetővé teszi, ez pedig a következő: a középső réteg, a már korábban emlíett, 2 elemre van felbontva, mindkettő egy trapéz, amiket helyesen egymás mellé illesztve, egy négyzet alakul. Az egyik trapéz látszó oldalai narancssárga-zöld-piros színűek, ha ennek az elemnek a narancssárga oldalára illeszted a bal hüvelykujjad és a piros oldalára a bal középső  ujjad, akkor egyszerűen hozzáférsz minden lehetséges forgatáshoz(a program használatához kötelező ez a tartás).  

A puzzle lehetséges forgatásai a következők: felső réteg forgatása, alsó réteg forgatása és a "slash". A felső és alsó rétegek elforgatása azon múlik, hogy az adott algoritmus, adott lépésében milyen szám áll. Korábban már említve volt, hogy az élek 30°, a sarkak pedig 60°-ot foglalnak el, egy másik értelmezése ennek, hogy a különböző elemeknek, különböző "súlya" van, ami eddig 30°-ot foglalt el, annak a súlya 1, míg a 60°-os elemeknek 2. Az algormitusokban a rétegek forgatásai (t,b)-vel vannak jelölve, ahol -6<t,b<=6 egész szám, a t azt jelöli, hogy hány "elemnyi súllyal" kell elforgatni a felső réteget, míg a b ugyan ez az alsó rétegre, ha felülről/alulról nézed a puzzle-t, akkor a pozitív számok óramutató járásával megegyező forgatást jelölnek, míg a negatívok ellenkező irányút, szokványos algoritmusokban nem szokott megjelenni a -6 szám, miután ugyan azt a forgatás éri el, mint a 6-os forgatás. Tehát a (-2,3) kifejezés azt jelenti, hogy a felső réteget 2 súllyal(60°-kal) az óramutató járásával ellentétes irányba kell forgatni, az alsó réteget pedig 3 súllyal(90°-kal) az óramutató járásával megegyező irányba kell forgatni. A "slash" az a forgatás, amikor a puzzle-t félbevágó sík mentén 180°-kal elforgatod, ilyenkor a forgatott fél által tartalmazott elemek réteget(és orientációt) cserélnek egymással, ez a forgatás az algoritmusokban "/"(forward slash) jellel van leírva. Tehát egy komplett algoritmus úgy néz ki, hogy (t<sub>1</sub>,b<sub>1</sub>)/(t<sub>2</sub>,b<sub>2</sub>)/.../(t<sub>n</sub>,b<sub>n</sub>). (Ez triviális, viszont mégis érdemes leírnom, a legtöbb algoritmust a puzzle egy bizonyos helyzetére kell elvégezni, ezért nem mindegy, hogy milyen az aktuális elforgatás, az kellő algoritmushoz képest. Ennek kiküszöbölése érdekében a program minden ilyen algoritmus előtt kiír egy "javító forgatást", ami annyit tesz, hogy az algoritmus elvégzéséhez helyes állapotba forgatja a puzzle rétegeit, ez a javító forgatás a tényleges algoritmustól 4 szóközzel van elválasztva.)

Összekeverés után nagy valószínüséggel a puzzle nem kocka alakú, bár létezik konkrét algoritmus a puzzle minden elem-tipusára nézett permutációjára, egyszerűen annyi különböző lehetőség van, hogy nem éri meg foglalkozni ezzel, a haladó kirakási metódusok is nagy részben intuíciót használnak, ezáltal a több mint 170 algoritmsu helyett, elég csak 5-öt megtanulni. Az intuíciót alkalmazó része a következő: el kell érni, hogy az alsó rétegbe kerüljön 6 darab sarok-elem, vagyis az asló rétegben csak sarkak lehetnek, a felső rétegben ezáltal 8 él és 2 sarok-elem van, ha ezután elvégzed az adott algoritmust akkor a puzzle (a középső réteg nem feltétlenül, de azt a kirakás végén lehet javítani) visszatér kocka alakúra, vagyis ekkor garanált, hogy a felső és alsó rétegekben 4 él és 4 sarok elem van, valamint hogy azok felváltva következnek egymás után, tehát az alsó és felső rétegek is visszatértek négyzet alapúra. A következő lépés az elemek orientálása, a szokványos kockához képest, itt az összes sarkot, majd az összes élet egy-egy algoritmussal helyes orientációba lehet hozni, sőt ha helyes algoritmusokat hajtunk végre, akkor orientálás után nem is tudnak többet réteget cserélni a kirakás során. Ezután a sarkak és élek permutálása következik, ezeket ugyan csak meg lehet oldani egy-egy algoritmussal. A kirakás utolsó lépése a középső réteg javítása, amennyiben kocka alapú már a középső réteg, nem kell semmit sem csinálnunk, ha viszont nem az, akkor van egy egyszerű algoritmus ami ezt megoldja.
